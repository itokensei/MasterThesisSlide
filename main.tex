\documentclass{beamer} % スライド用のレイアウト
% \documentclass[dvipdfmx,cjk]{beamer} 
% \documentclass[dvipdfm,cjk]{beamer} %% オプションは環境や利用するプログラムに
% \documentclass[dvips,cjk]{beamer}   %% よって変える

% \AtBeginDvi{\special{pdf:tounicode 90ms-RKSJ-UCS2}} %% しおりが文字化けしないように
% \AtBeginDvi{\special{pdf:tounicode EUC-UCS2}}

\usepackage{luatexja} % Beamer単体では日本語を出力できないのでこれを使う
\renewcommand{\kanjifamilydefault}{\gtdefault} % 漢字をゴシック体に指定

% \setbeamertemplate{navigation symbols}{} %% 右下のアイコンを消す

% \usetheme[block=fill]{metropolis} % usepackageじゃなくてusethemeだから注意
% \usetheme{Madrid}             %% theme の選択
% \usetheme{Boadilla}           %% Beamer のディレクトリの中の
% \usetheme{CambridgeUS}        %% Madrid.sty を指定
% \usetheme{Antibes}            %% 色々と試してみるといいだろう
% \usetheme{Montpellier}        %% サンプルが beamer\doc に色々とある．
% \usetheme{Berkeley}
% \usetheme{Goettingen}
% \usetheme{Singapore}
% \usetheme{Szeged}
\usetheme{Frankfurt}

\usecolortheme{beaver}
% \usecolortheme{rose}          %% colortheme を選ぶと色使いが変わる
% \usecolortheme{albatross}

% \useoutertheme{shadow}                 %% 箱に影をつける
\usefonttheme{professionalfonts}       %% 数式の文字を通常の LaTeX と同じにする

\setbeamercovered{transparent}         %% 消えている文字をうっすらと表示する

% \setbeamertemplate{theorems}[numbered]  %% 定理に番号をつける
% \newtheorem{thm}{Theorem}[section]
% \newtheorem{proposition}[thm]{Proposition}
% \theoremstyle{example}
% \newtheorem{exam}[thm]{Example}
% \newtheorem{remark}[thm]{Remark}
% \newtheorem{question}[thm]{Question}
% \newtheorem{prob}[thm]{Problem}

% \definecolor{katsuobushi}{HTML}{cd853f} % HTMLカラーコードで指定
% \setbeamercolor{frametitle}{bg=katsuobushi} % bgをfgにすると文字色が変わる
% {block title} % 全ブロックのタイトル．これのbgを指定するとブロックの本文もこれを薄くした色になる
% {block body} % 全ブロックの本文．
% {block title alarted} % alartblockのタイトル
% {block body alarted} % 同上本文
% {block title example} % exampleblockのタイトル
% {block body example} % 同上本文
% {normal text} % 本文．これのbgを指定するとスライドの背景色が変わる

%図
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary {shapes.misc}
\usetikzlibrary{positioning}
%数学マクロ  
\newcommand{\N}{\mathbb{N}}%自然数全体
\newcommand{\Z}{\mathbb{Z}}%有理整数環
\newcommand{\Q}{\mathbb{Q}}%有理数体
\newcommand{\R}{\mathbb{R}}%実数体
\newcommand{\C}{\mathbb{C}}%複素数体
\newcommand{\p}{\mathcal{P}}%冪
\renewcommand{\o}{\mathcal{O}}%開集合族
\newcommand{\U}{\mathcal{U}}%宇宙
%自分用の書き換え
\renewcommand{\epsilon}{\varepsilon}
\newcommand{\goldenmean}{\alpha}
\renewcommand{\phi}{\varphi}
\renewcommand{\subset}{\subseteq}
\renewcommand{\emptyset}{\varnothing}
%数学マクロ
\newcommand{\set}[1]{\{\,#1\,\}}%\midや;を用いる
\newcommand{\map}[3]{#1\colon#2\longrightarrow#3}
\newcommand{\Map}[2]{#1\stackrel{#2}{\longrightarrow}}%domainとarrowのみ
\newcommand{\pair}[1]{\langle#1\rangle}%山括弧
% \newcommand{\note}[1]{\quad(\,#1\,)}%補足
%一般マクロ
%%%%%%%%%%%特定の設定%%%%%%%%%%%%
%定理環境
% \usepackage{amsthm}
% \theoremstyle{definition}
\newtheorem{thm}{定理}
\newtheorem{dfn}[thm]{定義}
\newtheorem{prop}[thm]{命題}
\newtheorem{lem}[thm]{補題}
\newtheorem{cor}[thm]{系}
\newtheorem{cf}[thm]{例}
\newtheorem{rem}[thm]{注意}
\newtheorem{ex}[thm]{問題}
\newtheorem{axiom}[thm]{公理}
\newtheorem{ob}[thm]{観察}
\newtheorem{tr}[thm]{事実}
% \numberwithin{thm}{section}
% \newenvironment{definition}{\begin{dfn}}{\end{dfn}}
%数学マクロ
%圏論
\DeclareMathOperator{\Ob}{Ob}
\DeclareMathOperator{\Mor}{Mor}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\cod}{cod}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\Lim}{Lim}
\DeclareMathOperator{\Colim}{Colim}
\DeclareMathOperator{\Sing}{Sing}
\DeclareMathOperator{\sgn}{sgn}
\newcommand{\In}{\text{ in }}
\renewcommand{\c}{\mathcal{C}}%圏
\renewcommand{\d}{\mathcal{D}}
\newcommand{\e}{\mathcal{E}}
\newcommand{\I}{\mathbf{I}}%添字圏
\renewcommand{\j}{\mathscr{J}}
\newcommand{\SetCat}{\mathbf{Set}}
\newcommand{\Vect}{\mathbf{Vect}}
\newcommand{\Mod}{\mathbf{Mod}}
\newcommand{\Pos}{\mathbf{Pos}}
\newcommand{\Grp}{\mathbf{Grp}}
\newcommand{\Cat}{\mathbf{Cat}}
\newcommand{\Id}{\mathrm{Id}}%関手
\newcommand{\op}{\mathrm{op}}%双対
\newcommand{\placeholder}{{-}}%扱いをマイナス記号と区別
\newcommand{\yoneda}{\mbox{\textbf{よ}}}%米田埋込
\newcommand{\yoyoneda}{\mbox{\textbf{ね}}}%余米田埋込
\newcommand{\sSet}{\mathbf{sSet}}
\newcommand{\Top}{\mathbf{Top}}
\newcommand{\deltacat}{\mathbf{\Delta}}
\newcommand{\DFib}{\mathbf{DFib}}
\newcommand{\Spec}{\mathrm{Spec}}
\newcommand{\dutp}{\mathfrak{p}}
\newcommand{\dutq}{\mathfrak{q}}
\newcommand{\QCoh}{\mathrm{QCoh}}
%型理論
%証明木環境
\usepackage{bussproofs}
\EnableBpAbbreviations
\newcommand{\judge}[2]{#1\vdash#2}
\newcommand{\typejudge}[2]{\judge{#1}{#2\textsf{ type}}}
\newcommand{\contextjudge}[1]{#1\textsf{ cxt}}
\newcommand{\with}{\mathrel{\&}}
\newcommand{\parr}{\mathrel{\rotatebox[origin=c]{180}{\&}}}%乗法的選言
\newcommand{\0}{\mathbf{0}}
\newcommand{\1}{\mathbf{1}}
\newcommand{\2}{\mathbf{2}}
\newcommand{\miff}{
  \,\rotatebox[origin=c]{180}{\multimap}\mspace{-20mu}\multimap
}
\newcommand{\SF}{\mathbf{S4}}
\newcommand{\emptytype}{\mathbf{0}}
\newcommand{\unittype}{\mathbf{1}}
\newcommand{\refl}[1]{\mathsf{refl}_{#1}}
\newcommand{\nat}{\mathsf{N}}
\newcommand{\s}{\mathbb{S}}
\newcommand{\pr}{\mathsf{pr}}
\newcommand{\ap}[1]{\mathsf{ap}_{#1}}
\newcommand{\transport}[1]{\mathsf{transport}^{#1}}
\newcommand{\apd}[1]{\mathsf{apd}_{#1}}
\newcommand{\qinv}[1]{\mathsf{qinv}(#1)}
\newcommand{\isProp}[1]{\mathsf{isProp}(#1)}
\newcommand{\isequiv}{\mathsf{isequiv}}
\newcommand{\isContr}{\mathsf{isContr}}
\newcommand{\fib}{\mathsf{fib}}
\newcommand{\idtoeqv}{\mathsf{idtoeqv}}
\newcommand{\base}{\mathsf{base}}
\newcommand{\loopbase}{\mathsf{loop}}
\newcommand{\ft}{\mathsf{ft}}
\newcommand{\T}{\mathbf{T}}
\newcommand{\classify}[1]{\ulcorner#1\urcorner}
\newcommand{\HH}{\mathcal{H}}
\DeclareMathOperator*{\Conf}{\mathsf{Conf}}
\newcommand{\Conff}[1]{\Conf_{\set{1,\ldots,#1}}}
\newcommand{\Confff}[2]{\Conf_{\set{#1,\ldots,#2}}}
\newcommand{\Braid}{\mathrm{Br}}
\newcommand{\Bit}{\mathrm{Bit}}
\newcommand{\QBit}{\mathrm{QBit}}
\newcommand{\NOT}{\mathrm{NOT}}
\newcommand{\CNOT}{\mathrm{CNOT}}
\newcommand{\trace}{\mathrm{tr}}
\newcommand{\SK}{\mathsf{SK}}
%%量子論
%ブラ・ケット記法
\usepackage{braket}%\Setと\setが競合するから注意
%量子回路
\usepackage{quantikz}
%一般マクロ
\newcommand{\head}[1]{\overset{\downarrow}{#1}}

\title[トポロジカル量子コンパイル]{線型ホモトピー型理論を動機付けする\\
トポロジカル量子コンパイルの\\
形式検証に向けて}
\author[322301073 伊藤 賢世]{322301073 伊藤 賢世\\
アドバイザー：Jacques Garrigue}
\date{2025年1月30日}

\begin{document}
\begin{frame}
  \maketitle
\end{frame}

\begin{frame}
  \begin{block}{修論内容：サーベイ}
    Hisham Satiらの研究プロジェクト
    \begin{center}
      Quantum Certification
      via Linear Homotopy Types
    \end{center}
    を理解するための\structure{トポロジカル量子コンパイル}について
  \end{block}
  \begin{block}{研究概要}
    \begin{description}
      \item[主張] 信頼性のある量子コンピュータを実現するための
        検証言語「QS」 と
        その基礎理論「線型ホモトピー型理論（LHoTT）」の提唱.
      \item[研究者] Hisham Sati，Urs Schreiber，David J. Meyer，\(\ldots\)
      \item[拠点] ニューヨーク大学アブダビ校\\
        Center for Quantum and
        Topological Systems (CQTS)
    \end{description}
  \end{block}
\end{frame}

% 量子回路などの図を入れる
% コンパイルの全体図とSKアルゴリズムの部分
% トポロジカル量子コンパイル

\begin{frame}
  \begin{block}{概要}
    \begin{description}
      \item[前半] 修士論文では，量子コンピュータの誤りを排除する
        \structure{トポロジカル量子コンパイル}を主題として捉え，
        （古典）コンピュータ上で検証するための言語としてLHoTT（あるいはQS）を
        動機付ける．
      \item[後半] 本発表では，特にトポロジカル量子コンパイルの一般論である
        \structure{量子コンパイル}について説明する．
    \end{description}
  \end{block}
\end{frame}

\section{イントロダクション}
\begin{frame}[noframenumbering]{目次}
  \tableofcontents[currentsection]
\end{frame}

\begin{frame}
  \frametitle{イントロダクション}
  \begin{block}{重要課題：量子コンピュータの実現}
    \begin{itemize}
      \item 量子コンピュータ\(=\)量子力学の原理を活用した計算機．
      \item 普及している（古典）コンピュータの性能を
            凌駕する量子コンピュータ上のアルゴリズムがいくつか見つかっている．
            %\item IBMやGoogleなども巨額の投資．
    \end{itemize}
    \begin{center}
      \(\longrightarrow\)
      量子コンピュータの実現に対する期待は計り知れない．
    \end{center}
  \end{block}
\end{frame}

% \begin{frame}
%   \frametitle{イントロダクション}
%   \begin{block}{修論概要}
%     \[
%       \underbrace{
%         \begin{array}{rccc}
%           \text{ソフトウェア側} & \stackrel{\text{コンパイル}}{\longrightarrow} & \text{ハードウェア側}   \\
%           \text{量子回路}    & \longmapsto                              & \text{実行可能な量子回路}
%         \end{array}
%       }_{\text{形式検証}}
%     \]
%   \end{block}
% \end{frame}

\begin{frame}
  \frametitle{イントロダクション}
  \begin{block}{計算の信頼性における課題①：Decoherence}
    \begin{itemize}
      \item 量子コンピュータのデータ\(=\)量子系の状態
            （\structure{量子ビット}）．
            \begin{itemize}
              \item \(n\)量子ビット\((\C^2)^{\otimes n}:=\underbrace{
                      \C^2\otimes\cdots\otimes\C^2}_{n\text{個}}\)
                    % \item \(\ket{\phi}=c_0\ket{0} + c_1\ket{1}\in\QBit:=\C^2\)
                    % \item \(\QBit^{\otimes n}:=\underbrace{
                    %         \QBit\otimes\cdots\otimes\QBit}_{n\text{個}}\)
            \end{itemize}
      \item 量子状態は環境の影響で壊れやすい
            （\structure{Decoherence問題}）．
    \end{itemize}
    \begin{center}
      \(\longrightarrow\)
      エラーが多く，アルゴリズム通りに計算することは難しい．
    \end{center}
  \end{block}

  % \begin{block}{アプローチ①：エラーの訂正}
  %   \begin{itemize}
  %     \item 古典コンピュータでも物理レベルではエラーが起きている．
  %           \begin{itemize}
  %             \item データに冗長性をもたせて，データを復元
  %                   （誤り訂正理論）．
  %           \end{itemize}
  %     \item 量子コンピュータにも応用（量子誤り訂正）．
  %   \end{itemize}
  %   \begin{center}
  %     \(\longrightarrow\)
  %     量子ビットを大規模に用意する問題に至る．
  %   \end{center}
  % \end{block}
\end{frame}

\begin{frame}
  \begin{block}{アプローチ：エラーの低減}
    \begin{itemize}
      \item \structure{トポロジカル量子計算}
            \begin{itemize}
              \item トポロジーで量子状態を構成．
              \item \structure{組み紐}で計算を実行．
                    \begin{center}
                      \tikzset{cross/.style={preaction={-,draw=white,line width=6pt}}}
                      \begin{tikzpicture}[auto, ->]
                        \node (a) at (0,4) {\(1\)}; \node (a') at (6,4) {\(1\)};

                        \node (b) at (0,2.5) {\(i\)}; \node (b') at (6,2.5) {\(i\)};
                        \node (c) at (0,1.5) {\(i+1\)}; \node (c') at (6,1.5) {\(i+1\)};

                        \node (d) at (0,0) {\(n\)}; \node (d') at (6,0) {\(n\)};

                        \draw (a) to (a');

                        \draw (c) to[out=-1,in=179] (b');
                        \draw (b)[cross] to[out=1,in=181] (c');

                        \draw (d) to node[swap] {worldline} (d');

                        \node (e) at (3,3) {\rotatebox{90}{\(\cdots\)}};
                        \node (e) at (3,1) {\rotatebox{90}{\(\cdots\)}};
                      \end{tikzpicture}
                    \end{center}
            \end{itemize}
      \item Decoherenceに影響されにくく，エラーが減る．
    \end{itemize}
    % \begin{center}
    %   \(\longrightarrow\)
    %   訂正のための冗長な量子ビットは少なくて済む．
    % \end{center}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{イントロダクション}
  \begin{block}{コンパイル}
    \begin{itemize}
      \item あるプログラミング言語で書かれたコードを，
            数学的な意味を保ちつつ，
            別のコードに変換することを\structure{コンパイル}という．
      \item そのプログラムを\structure{コンパイラ}という．
      \item 特に，コンピュータが実行可能なコードに変換したりする．
      \item また，コードの実行に関する最適化が施される．
    \end{itemize}
  \end{block}

  \begin{exampleblock}{例}
    \begin{description}
      \item[Cコンパイラ] C言語\(\to\)アセンブリ言語
      \item[アセンブラ] アセンブリ言語\(\to\)機械語
    \end{description}
    古典コンピュータは最終的に機械語を実行している．
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{イントロダクション}
  \begin{block}{量子回路}
    \begin{itemize}
      \item 計算は\structure{量子ゲート}によって実行される．
            \begin{itemize}
              \item 量子系の\structure{ユニタリ変換}
                    \(\map{U}{(\C^2)^{\otimes n}}{(\C^2)^{\otimes n}}\)．
            \end{itemize}
      \item \structure{量子回路}は量子ゲートで構成され，
            アルゴリズムを記述．
            \[
              \CNOT(H\otimes I)\ket{00},\quad
              \begin{quantikz}[thin lines]
                \lstick{$\ket{0}$} & \gate{H} & \ctrl{1} & \qw \\
                \lstick{$\ket{0}$} & \qw      & \targ{} & \qw
              \end{quantikz}
            \]
    \end{itemize}
  \end{block}

  \begin{block}{量子コンパイル：
      計算したい量子回路\(\to\)実行可能な量子回路}
    \begin{itemize}
      \item 任意の量子ゲートを準備し実行可能にするのは現実的でない．
      \item 有限個のみ準備（\structure{基本ゲート}）し，
            その量子回路で実行する．
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{イントロダクション}
  \begin{block}{量子コンパイルの特徴}
    基本ゲートの組み合わせで，
    任意の量子アルゴリズムを
    \alert{正確に}シミュレートすることはできない．
    \begin{center}
      \(\longrightarrow\)
      任意の精度で\alert{近似的に}シュミレートする．\\
      （cf. \structure{Solovay・Kitaevアルゴリズム}）
    \end{center}
  \end{block}

  \begin{alertblock}{注意}
    後半では，Solovay・Kitaevアルゴリズムを説明する．
  \end{alertblock}

  \begin{block}{課題①の先：トポロジカル量子コンパイル}
    トポロジカル量子コンピュータの量子コンパイル．
    \begin{itemize}
      \item 量子ゲート\(=\)\structure{組み紐ゲート}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{イントロダクション}
  \begin{block}{コンパイルの形式検証}
    古典コンピュータでは，コンパイルが正しいことの検証が研究されている．
    \begin{itemize}
      \item コンパイラの仕様を検証言語で記述し，
            コードの数学的な意味が保たれることを証明する．
      \item cf. Cコンパイラの1つCompCertの正しさは，
            Coqで検証．
    \end{itemize}
  \end{block}
  \begin{alertblock}{計算の信頼性における課題②：コンパイルの正しさ}
    トポロジカル量子コンパイルの形式検証
    \begin{itemize}
      \item 量子回路の記述
      \item トポロジカル量子ゲートの記述
    \end{itemize}
  \end{alertblock}
\end{frame}

\begin{frame}
  \frametitle{イントロダクション}
  \begin{block}{Satiらの提案：線型ホモトピー型理論（LHoTT）}
    \begin{itemize}
      \item LHoTT = Linear + HoTT.
      \item 量子回路の記述\(\to\)\structure{QS} \(\subset\) LHoTT
      \item トポロジカル量子ゲートの記述\(\to\)
            \structure{HoTT} \(\subset\) LHoTT
    \end{itemize}
    \begin{center}
      \(\longrightarrow\)
      LHoTTは信頼性のある量子プログラミングに対する\\
      最初の包括的なパラダイムになる．
    \end{center}
  \end{block}
\end{frame}

% \begin{frame}
%   \frametitle{イントロダクション}
%   \begin{block}{修論概要}
%     \[
%       \begin{array}{rccc}
%         \text{ソフトウェア側} & \stackrel{\text{量子コンパイル}}{\longrightarrow} & \text{ハードウェア側}   \\
%         \text{量子回路}    & \longmapsto                                & \text{実行可能な量子回路}
%       \end{array}
%     \]
%     \[
%       \underbrace{
%         \begin{array}{rccc}
%           \text{ソフトウェア側} & \stackrel{\text{トポロジカル量子コンパイル}}{\longrightarrow} & \text{(トポロジカル)ハードウェア側} \\
%           \text{量子回路}    & \longmapsto                                      & \text{(組み紐に対応する) 量子回路}
%         \end{array}
%       }_{\text{形式検証}}
%     \]
%   \end{block}
% \end{frame}

\section{量子コンパイル}
\begin{frame}[noframenumbering]{目次}
  \tableofcontents[currentsection]
\end{frame}

\begin{frame}
  \frametitle{量子コンパイル}
  近似するには，距離の概念を要する．以下，\(d=2^n\)とする．
  \begin{dfn}[ユニタリ変換の間の距離]
    任意の\(U,V\in U(d)\)に対し，その距離を次で定義する．
    \[
      d(U,V):=||U-V||=\sup_{||\psi||=1}||(U-V)\ket{\psi}||
    \]
  \end{dfn}
\end{frame}

\begin{frame}
  \frametitle{量子コンパイル}
  \begin{dfn}[Universal set]
    ゲートの集合\(\mathcal{G}\)が\(U(d)\)に対して
    \structure{万能(universal)}であるとは，
    任意の\(U\in U(d)\)と\(\epsilon >0\)に対し，
    ある\(l\in\N\)と\(G_1,\ldots,G_l\in\mathcal{G}\)
    が存在して，\(d(U,G_l\cdots G_1)<\epsilon\)となることである．
    有限列\(G_1,\ldots,G_l\)を\(U\)の
    \structure{\(\epsilon\)近似列}といい，
    \(l\)を長さという．
  \end{dfn}

  % \begin{exampleblock}{例}
  %   \begin{itemize}
  %     \item
  %     \item
  %           \(\set{H,\CNOT,T}\)は\(U(d)\)
  %           に対して万能ゲート集合である．
  %   \end{itemize}
  % \end{exampleblock}
\end{frame}

% \begin{frame}{量子コンパイル}
%   \begin{exampleblock}{例}
%     \(\set{H,CNOT,T}\)は\(U(d)\)に対して万能である．
%   \end{exampleblock}
% \end{frame}

\begin{frame}{量子コンパイル}
  \begin{itemize}
    \item \(U(d)\)の元は\(U(2)\cup\set{\CNOT}\)の元の合成で表せる．
    \item \(U(2)\)の元は\(SU(2)\)の元の合成で表せる．
          ただし，物理的な意味を持たない大域的な相を無視する．
          \begin{center}
            \(\longrightarrow\)
            よって，\(SU(2)\)の元が近似できればよい．
          \end{center}
  \end{itemize}
  \begin{dfn}[Instruction set]
    ゲートの有限集合\(\mathcal{G}\)が\structure{instruction set}であるとは，次の3つの条件を満たすことである．
    \begin{enumerate}
      \item \(\mathcal{G} \subset SU(2)\)．
      \item \(\mathcal{G}\)は逆行列で閉じている．
      \item \(\mathcal{G}\)は\(SU(2)\)に対してuniversalである．
    \end{enumerate}
  \end{dfn}
\end{frame}

% \begin{frame}{量子コンパイル}
%   このinstruction setを仮定すると，
%   その長さの上限が\(\epsilon\)を用いて与えられる．
%   \begin{thm}[Solovay・Kitaevの定理]
%     instruction setに対し，
%     ある定数\(c\)があって，任意の\(U\in SU(d)\)を
%     \(\epsilon\)の精度で近似するとき，
%     近似列の長さは\(O(\log^c(1/\epsilon))\)
%     に抑えられる．
%   \end{thm}
%   このままだと近似列の存在はわかっても，その見つけ方がわからない．
%   Solovay・Kitaevの定理を用いて，
%   近似列を見つけるアルゴリズムを与える．
% \end{frame}

\begin{frame}
  \frametitle{量子コンパイル}
  \begin{thm}[Solovay・Kitaevアルゴリズム]
    \label{SK algrithm}
    \(\mathcal{G}\subset SU(2)\)をinstruction setとする．
    ある正数列\((\epsilon_n)\)であって，
    \[
      \epsilon_n < \epsilon_{n-1},\quad \epsilon_n\to 0
    \]
    となるものが存在し，次を満たす．
    任意のゲート\(U\in SU(2)\)と深さ\(n\)を入力して，
    \(\epsilon_n\)近似列
    \(G_1,\ldots,G_{l_n}\in \mathcal{G}\)並びに
    量子回路\(G_{l_n}\cdots G_1\)
    を出力するSKアルゴリズム
    \(\SK(U,n)\)が帰納的に定義できる．（続く）
  \end{thm}
\end{frame}

\begin{frame}{量子コンパイル}
  \begin{thm}[Solovay・Kitaevアルゴリズム]
    \(\cdots\)このとき，任意の\(\epsilon\)に対し\(n\)を適当に選ぶことで
    近似列が得られ，
    近似列の長さ\(l_n\)とSKアルゴリズムの実行時間\(t_n\)が
    次のように評価できる．
    \begin{align*}
      n   & = \left\lceil\frac{\ln[\frac{\ln(1/\epsilon c^2)}{\ln(1/\epsilon_0 c^2)}]}{\ln(3/2)}\right\rceil, \\
      l_n & = O(\ln^{\ln 5/ln(3/2)}(1/\epsilon)),                                                             \\
      t_n & = O(\ln^{\ln 3/ln(3/2)}(1/\epsilon)).
    \end{align*}
  \end{thm}
\end{frame}

\begin{frame}{量子コンパイル：SKアルゴリズムの証明}
  % c_0 -> c -> \epsilon_0 -> l_0 -> U -> U_0
  （証明）次のStep0〜Step2でSKアルゴリズムを帰納的に定義する．
  その前にStep2で登場する定数\(c\)に対し，
  \(\epsilon_0 < 1/c^2\)なる定数をとる．
  \begin{exampleblock}
    {Step0: 初期近似列のbrute-force search}
    \(\epsilon_0\)に対して，
    ある長さ\(l_0\)が存在して，次を満たす．
    \(U\in SU(2)\)に対し，
    \(\epsilon_0\)近似列
    \(L_0 \in \coprod_{0 < l \leq l_0}\mathcal{G}^l\)
    がとれる．
    その量子回路を\(U_0\)とおく．
    \(\SK(U,0) := (L_0;U_0)\)と定義する．
  \end{exampleblock}
\end{frame}

\begin{frame}{量子コンパイル：SKアルゴリズムの証明}
  \begin{exampleblock}{Step1: 群交換子による分割}
    \(n\geq 1\)に対し，
    \((L_{n-1};U_{n-1}) := \SK(U,n-1)\)とおく．
    ある分割
    \begin{equation*}\label{gc decomp}
      UU_{n-1}^\dagger = \Delta = VWV^\dagger W^\dagger,\quad
      d(I,V),d(I,W) < c_0\sqrt{\epsilon_{n-1}}
    \end{equation*}
    によって，\(V,W\in\mathcal{G}\)を得る．
    ただし，\(c_0\approx\frac{1}{\sqrt{2}}\)で定数．
  \end{exampleblock}
\end{frame}

\begin{frame}{量子コンパイル：SKアルゴリズムの証明}
  \begin{exampleblock}
    {Step2: 交換因子にSKアルゴリズム}
    \(V,W\)に対してSKアルゴリズムを適用する．
    \[
      (L_V;V_{n-1}):=\SK(V,n-1),\quad
      (L_W;W_{n-1}):=\SK(W,n-1).
    \]
    このとき，
    \(\Delta_{n-1}:= V_{n-1}W_{n-1}
    V_{n-1}^\dagger W_{n-1}^\dagger\)
    とおくと，
    \begin{align}
      d(\Delta,\Delta_{n-1})
       & < \epsilon_n
      :=c\epsilon_{n-1}^\frac{3}{2},\quad \\
      \epsilon_{n-1}
       & <\frac{1}{c^{2}} \label{sk leq}
    \end{align}
    を満たす．
    ただし，\(c\approx 8c_0\approx 4\sqrt{2}\)で定数．
    \[
      U_{n}     := \Delta_{n-1} U_{n-1},\quad
      \SK(U,n)  :=(L_{n-1}L_W^\dagger L_V^\dagger L_W L_V;
      U_{n})
    \]
  \end{exampleblock}
\end{frame}

\begin{frame}{量子コンパイル：SKアルゴリズムの証明}
  この手続きにより，
  \(U_{n-1}U^\dagger = \Delta_{n-1}
  U_{n-1}U^\dagger = \Delta_{n-1} \Delta^\dagger\)
  となるから，
  \[
    d(U,U_{n-1})=d(I,U_{n-1}U^\dagger)
    =d(I,\Delta_{n-1}\Delta^\dagger)=d(\Delta,\Delta_{n-1})
    < \epsilon_n
  \]
  と評価できる．
  また，不等式（\ref{sk leq}）により
  \(\epsilon_n < \epsilon_{n-1}\)を満たす．
  \(\epsilon_0\)は，
  不等式（\ref{sk leq}）を満たすようにとっていたので，
  帰納的定義がうまくいっている．

  定理の後半は，手続きの定め方から
  \begin{align*}
    l_n & = 5l_{n-1},                  \\
    t_n & \leq 3t_{n-1} + \text{const}
  \end{align*}
  となり，示せる．（証明終わり）
\end{frame}

\section{まとめ}
\begin{frame}[noframenumbering]{目次}
  \tableofcontents[currentsection]
\end{frame}

\begin{frame}
  \frametitle{まとめ}
  \begin{block}{振り返り}
    \begin{itemize}
      \item 修士論文では，量子コンピュータの誤りを排除する
            トポロジカル量子コンパイルを主題として捉え，
            （古典）コンピュータ上で検証するための言語としてLHoTT（あるいはQS）を
            動機付けることがねらいであった．
      \item 本発表では，特にトポロジカル量子コンパイルの一般論である
            量子コンパイルについて，具体的に説明した．
    \end{itemize}
  \end{block}
\end{frame}
% \begin{block}{展望}
%   \begin{itemize}
%     \item LHoTTの詳細な構文論と意味論
%     \item 安定ホモトピー論
%     \item 状態空間の具体的な構成
%     \item トポロジカル量子計算によるdecoherence耐性の記述
%     \item 共形場理論やChern・Simons理論を含む場の量子論
%     \item 物質のトポロジカル秩序相
%     \item トポロジカル量子計算の形式検証
%           のためのTED-\(K\)理論
%     \item LHoTTのcompanion articles
%   \end{itemize}
% \end{block}

% \begin{frame}
%   \frametitle{一枚目のスライド}
%   普通に文中で\LaTeX コマンドが使用できます．（そらそう）
%   \begin{block}{ブロックのタイトル}
%     block環境を作成しbeginの第二引数にタイトルを渡すとこうなります．
%   \end{block}
%   \begin{alertblock}{アラート}
%     alertblockを指定するとこんな風になります．
%   \end{alertblock}
%   \begin{exampleblock}{例}
%     exampleblockを指定するとこうなります．
%   \end{exampleblock}
% \end{frame}

% \begin{frame}
%   \frametitle{横並べ}
%   スライドで左右比較するときなどにこのようにします
%   \begin{columns}
%     \begin{column}{.4\linewidth} % 現在の環境の幅の0.4(=40%)の意
%       \begin{block}{内容1}
%         内容1内容1内容1内容1内容1内容1内容1内容1内容1内容1内容1内容1内容1内容1
%       \end{block}
%     \end{column}
%     \begin{column}{.4\linewidth}
%       \begin{block}{内容2}
%         内容2内容2内容2内容2内容2内容2内容2内容2内容2内容2内容2内容2内容2内容2
%       \end{block}
%     \end{column}
%   \end{columns}
%   このとき各columnの幅は合計100\%にしてしまうとデザイン的にあんまよくないです
% \end{frame}

% \begin{frame}
%   \frametitle{Overlay}
%   \begin{itemize}
%     \item 一個目
%           \pause % このコマンドを打つごとに一時停止する
%     \item 二個目
%           \pause
%     \item 三個目
%           \pause
%     \item 四個目
%   \end{itemize}
% \end{frame}

% \begin{itemize}
%   \item<1-> 一個目（一画面目以降表示）
%   \item<2-> 二個目（二画面目以降表示）
%   \item<3-> 三個目（三画面目以降表示）
%   \item<1-2> 四個目（二画面目まで表示）
% \end{itemize}

% \begin{frame}
%   \frametitle{Item以外のOverlay}
%   \begin{block}{常に表示1}
%   \end{block}
%   \uncover<2->{二画面目以降のみ表示(uncover)}
%   \begin{block}{常に表示2}
%   \end{block}
%   \only<2->{二画面目以降のみ表示(only)}
%   \begin{block}{常に表示3}
%   \end{block}
% \end{frame}
\end{document}